#include <iostream>
#include <stdexcept>
#include <omp.h>

#include <cmath>
#include <limits>
template<class T>
bool almost_equal(T x, T y, int ulp) {
    return std::fabs(x-y) <= std::numeric_limits<T>::epsilon() * std::fabs(x+y) * ulp ||  std::fabs(x-y) < std::numeric_limits<T>::min();
}

template<class T>
void test_{{name}}(){

 // Input and Outputs
 {% for l in loops %}
 const int {{ l.N }} = {{l.v}};
 {%- endfor %}

T counter{};

// Main program
{% for fat_pragma in fat_path %}
#pragma omp {{fat_pragma["pragma"]}} {% if "reduce" in fat_pragma %} reduction(+:counter) {%endif%} {% if "target" in fat_pragma %} map(tofrom:counter) {% endif %}
{% if "loop" in fat_pragma %}
    for (int {{fat_pragma["loop"].i}} = 0 ; {{fat_pragma["loop"].i}} < {{fat_pragma["loop"].N}} ; {{fat_pragma["loop"].i}}++ )
{% endif %}
{
{% if "only_teams" in fat_pragma %}
const int num_teams = omp_get_num_teams();
{% endif %}
{% if "only_parallel" in fat_pragma %}
const int num_threads = omp_get_num_threads();
{% endif %}
{% endfor %}

{% if balenced %}
counter = counter + 1;
{% elif only_teams and only_parallel %}
counter = counter + 1./(num_teams*num_threads);
{% elif only_teams  %}
counter = counter + 1./num_teams;
{% elif only_parallel  %}
counter = counter + 1./num_threads;
{% endif %}

{% for fat_pragma in fat_path %}
}
{% endfor %}

// Validation
if ( !almost_equal(counter,T{ {{expected_value}} }, 1)  ) {
    std::cerr << "Expected: " << {{expected_value}} << " Get: " << counter << std::endl;
    throw std::runtime_error( "{{name}} give incorect value when offloaded");
}

}
int main()
{
    test_{{name}}<double>();
}

