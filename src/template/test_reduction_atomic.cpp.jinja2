{% from 'utils.cpp.jinja2' import prologue_general, prologue_function, epilogue_function, increment with context%}

{{ prologue_general(T_category, balenced) }}

void test_{{name}}(){

{{ prologue_function(T, loops) }}

{% for fat_pragma in fat_path %}
{% if "partial" in fat_pragma%}
{{T}} partial_counter{};
#pragma omp {{fat_pragma["pragma"]}} reduction(+: partial_counter)
{% else %}
#pragma omp {{fat_pragma["pragma"]}} {% if "partial_reduce" in fat_pragma %} reduction(+: partial_counter) {%endif%} {% if "target" in fat_pragma %} map(tofrom:counter) {% endif %}
{% endif %}

{% if "loop" in fat_pragma %}
    for (int {{fat_pragma["loop"].i}} = 0 ; {{fat_pragma["loop"].i}} < {{fat_pragma["loop"].N}} ; {{fat_pragma["loop"].i}}++ )
{% endif %}
    {
{% if "only_teams" in fat_pragma %}
const int num_teams = omp_get_num_teams();
{% elif "only_parallel" in fat_pragma %}
const int num_threads = omp_get_num_threads();
{% endif %}
{% endfor %}

{{ increment('partial_counter', T, balenced, only_teams, only_parallel) }}

{% for fat_pragma in fat_path|reverse %}
   } 
{%if "partial" in fat_pragma%}
#pragma omp atomic update
counter += partial_counter;
{% endif %}
{% endfor %}

{{ epilogue_function(T, expected_value) }}
}
int main()
{
    test_{{name}}();
}

