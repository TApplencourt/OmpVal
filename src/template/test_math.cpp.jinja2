{% if have_complex == "complex" %}
#include <complex>
{% endif %}
#include <cmath>

#include <limits>
#include <iostream>
#include <stdexcept>

using namespace std;

{% for output_type in l_output | unique(attribute='T.no_pt') %} 
bool almost_equal({{output_type.T.no_pt}} x, {{output_type.T.no_pt}} y, int ulp) {
{% if output_type.category in ("integer","bool")  %}
    return x == y ; 
{% elif output_type.T.category == "float" %}
     return std::fabs(x-y) <= std::numeric_limits<{{output_type.T.no_pt}}>::epsilon() * std::fabs(x+y) * ulp ||  std::fabs(x-y) < std::numeric_limits<{{output_type.T.no_pt}}>::min();
{% elif output_type.T.category == "complex" %}
    return std::abs(x-y) <= 2*std::numeric_limits<{{output_type.T.no_pt}}>::epsilon() * std::abs(x+y.real) * ulp ||  std::abs(x-y) < std::numeric_limits<{{output_type.T.no_pt}}>::min();
{% endif %}
}
{% endfor %}

void test_{{name}}(){
   {% for input in l_input %}
   {{input.T}} {{input.name}} {  {{input.val}} };
   {% endfor %}

   {% for output in l_output %}
   {{output.T.no_pt}} {{output.name}}_host ;
   {{output.T.no_pt}} {{output.name}}_gpu ;
   {% endfor %}

   {{scalar_output}}_host = {{name}}( {{ l_argv_host | join(', ') }});

   #pragma omp target map(from: {{ l_output_gpu | join(', ')  }} )
   {
   {{scalar_output}}_gpu = {{name}}( {{ l_argv_gpu | join(', ') }});
   }

   {% for output in l_output %}
   if ( !almost_equal({{output.name}}_host,{{output.name}}_gpu,1) ) {
        std::cerr << "Host: " << {{output.name}}_host << " GPU: " << {{output.name}}_gpu << std::endl;
        throw std::runtime_error( "{{name}} give incorect value when offloaded");
    }
    {% endfor %}
}

int main()
{
    test_{{name}}();
}

