#include <iostream>
#include <limits>

{% if T_category == "complex" %}
#include <complex>
using namespace std;
{% endif %}
#include <vector>
#include <algorithm>

bool almost_equal({{T}} x, {{T}} y, int ulp) {
{% if T_category == "float" %}
     return std::fabs(x-y) <= std::numeric_limits<{{T}}>::epsilon() * std::fabs(x+y) * ulp ||  std::fabs(x-y) < std::numeric_limits<{{T}}>::min();
{% elif T_category == "complex" %}
    bool r = std::fabs(x.real()-y.real()) <= std::numeric_limits<{{T_type}}>::epsilon() * std::fabs(x.real()+y.real()) * ulp ||  std::fabs(x.real()-y.real()) < std::numeric_limits<{{T_type}}>::min();
    bool i = std::fabs(x.imag()-y.imag()) <= std::numeric_limits<{{T_type}}>::epsilon() * std::fabs(x.imag()+y.imag()) * ulp ||  std::fabs(x.imag()-y.imag()) < std::numeric_limits<{{T_type}}>::min();
    return r && i;
{% endif %}
}

void test_{{name}}(){
  // Input and Outputs
  {% for l in loops %}
  const int {{ l.N }} = {{l.v}};
  {%- endfor %}
  const int size = {{size}};
  std::vector<{{T}}> A(size);
  std::vector<{{T}}> B(size);
  std::generate(B.begin(), B.end(), std::rand);

  {{T}} *pA = A.data();
  {{T}} *pB = B.data();

// Main program
{% for fat_pragma in fat_path %}
#pragma omp {{fat_pragma["pragma"]}} {% if "target" in fat_pragma %}  map(from: pA[0:{{size}}]) map(to: pB[0:{{size}}]) {% endif %}
{% if "loop" in fat_pragma %}
    for (int {{fat_pragma["loop"].i}} = 0 ; {{fat_pragma["loop"].i}} < {{fat_pragma["loop"].N}} ; {{fat_pragma["loop"].i}}++ )
{% endif %}
{
{% endfor %}

pA[ {{index}} ] = pB [ {{index}} ];

{% for fat_pragma in fat_path %} } {% endfor %}

// Validation
for (int i = 0 ;  i < size ; i++) {
    if ( !almost_equal(A[i],B[i],1) ) {
         std::cerr << "Expected: " << B[i] << " Got: " << A[i] << std::endl;
        throw std::runtime_error( "{{name}} give incorect value when offloaded");
    }
}
 
}

int main()
{
    test_{{name}}();
}
